#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     touchSensor,    sensorTouch)
#pragma config(Sensor, S3,     lightSensor,    sensorNone)
#pragma config(Sensor, S4,     sonarSensor,    sensorNone)
#pragma config(Motor,  mtr_S1_C1_1,     motorArmLeft,  tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorArmRight, tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorDriveLeft, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorDriveRight, tmotorTetrix, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This is for the NXT model, not TETRIX

/************************************\
|*  ROBOTC Virtual World            *|
|*                                  *|
|*  DO NOT OVERWRITE THIS FILE      *|
|*  MAKE SURE TO "SAVE AS" INSTEAD  *|
\************************************/
// The robot will move towards and hit the crate depending on the encoder target value

const int speed = -50;
const int pause = 1500;

void goStraight() {
  nMotorEncoder(motorDriveLeft) = 0;
  nMotorEncoder(motorDriveRight) = 0;
  while (nMotorEncoder(motorDriveLeft) <7500 && nMotorEncoder(motorDriveRight) < 7500) {
    motor[motorDriveLeft] = speed;
    motor[motorDriveRight] = speed;
  }
}

void pauseBot() {
  motor[motorDriveLeft] = 0;
  motor[motorDriveRight] = 0;
  wait1Msec(pause);
}

void turnAround() {
  nMotorEncoder(motorDriveLeft) = 0;
  nMotorEncoder(motorDriveRight) = 0;
  while (nMotorEncoder(motorDriveLeft) < 1650 && nMotorEncoder(motorDriveRight) < 1650){
    motor[motorDriveLeft] = -speed;
    motor[motorDriveRight] = speed;
  }
}

void goStraight2() {
  nMotorEncoder(motorDriveLeft) = 0;
  nMotorEncoder(motorDriveRight) = 0;
  while (nMotorEncoder(motorDriveLeft) < 2000 && nMotorEncoder(motorDriveRight) < 2000) {
    motor[motorDriveLeft] = speed;
    motor[motorDriveRight] = speed;
  }
}

void turnAround2() {
  nMotorEncoder(motorD) = 0;
  nMotorEncoder(motorE) = 0;
  while (nMotorEncoder(motorD) < 700 && nMotorEncoder(motorE) < 700) {
    motor[motorD] = -speed;
    motor[motorE] = speed;
  }
}

  void goStraight3() {
  nMotorEncoder(motorD) = 0;
  nMotorEncoder(motorE) = 0;
  while (nMotorEncoder(motorD) < 17000 && nMotorEncoder(motorE) < 17000) {
    motor[motorD] = speed;
    motor[motorE] = speed;
  }
}



task main () {
  goStraight();
  pauseBot();
  turnAround();
  pauseBot();
  goStraight2();
  pauseBot();
  turnAround2();
  pauseBot();
  goStraight3();
}
