#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     motorL,        tmotorMatrix, openLoop, reversed, driveLeft)
#pragma config(Motor,  mtr_S1_C1_2,     motorR,        tmotorMatrix, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int gOffset,value=0;
float turned=0
float multiplier=2162.0/1573.0;
long lastTime=0;

void progressBar(int l,int x, int y){
	char aa=' ',bb=' ',cc=' ',dd=' ',ee=' ',ff=' ',gg=' ',hh=' ',ii=' ',jj=' ',kk=' ',ll=' ',mm=' ',nn=' ',oo=' ';
	int prog = x/(y/16);
	switch(prog){
		case 16:
		case 15:
			oo='=';
		case 14:
			nn='=';
		case 13:
			mm='=';
		case 12:
			ll='=';
		case 11:
			kk='=';
		case 10:
			jj='=';
		case 9:
			ii='=';
		case 8:
			hh='=';
		case 7:
			gg='=';
		case 6:
			ff='=';
		case 5:
			ee='=';
		case 4:
			dd='=';
		case 3:
			cc='=';
		case 2:
			bb='=';
		case 1:
			aa='=';
	}
	nxtDisplayTextLine(l,"|%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c|",aa,bb,cc,dd,ee,ff,gg,hh,ii,jj,kk,ll,mm,nn,oo);
}

void calibrateGyro(int samples){
	nxtDisplayCenteredTextLine(3,"Calibrating...");
	gOffset=0;
	for(int i=0; i<samples; i++){
		gOffset+=SensorValue[Gyro];
		wait1Msec(4);
		progressBar(4,i,samples);
	}
	gOffset/=samples;
}

void resetGyro(){
	nxtDisplayTextLine(2,"-----------------",);
	nxtDisplayTextLine(5,"-----------------",);
	turned=0;
	clearTimer(T4);
	calibrateGyro(512);
}

task main(){
	clearTimer(T4);
	calibrateGyro(512);
	while(true){
		value = SensorValue[Gyro];
		if(abs(value)<2)value=-gOffset;
		turned+=(float)(value-gOffset)*720.0*(float)(time1(T4)-lastTime)*multiplier/1023000.0;
		lastTime=time1(T4);
		nxtDisplayCenteredBigTextLine(0,"%d",value);
		nxtDisplayCenteredBigTextLine(2,"%d",(value-gOffset));
		nxtDisplayCenteredBigTextLine(4,"%d",turned);
		if(nNxtButtonPressed==3)resetGyro();
		wait1Msec(5);
	}
}

//void gturn(int x,int v){//resolution of 0.01 degrees, and input in numbers of 0.01 degrees
//	int turned=0;
//	int lastTime=0;
//	calibrateGyro(128);
//	if(x<0){
//		wheel(-v,v,0);
//		}else if(x>0){
//		wheel(v,-v,0);
//		}else{
//		return;
//	}
//	clearTimer(T4);
//	while(abs(turned)<abs(x)){
//		turned+=(SensorValue[Gyro]-gOffset)*36000*time1(T4)/1024000;
//		clearTimer(T4);
//		nxtDisplayCenteredBigTextLine(0,"%d",x);
//		nxtDisplayCenteredBigTextLine(2,"%d",turned);
//	}
//	return;
//}
